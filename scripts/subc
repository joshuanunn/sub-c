#!/usr/bin/env bash

set -Eeuo pipefail
trap cleanup SIGINT SIGTERM ERR EXIT

script_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd -P)

usage() {
  cat <<EOF
Usage: $(basename "${BASH_SOURCE[0]}") [-h] [-d] [--lex|--parse|--irgen|--codegen|--emit|-S|-c] sourcefile
Sub-C compiler driver.
Available options:
 -h, --help      Print this help and exit
 -d, --debug     Print script debug info
     --lex       [ stdout ] Run -> lexer
     --parse     [ stdout ] Run -> parser
     --validate  [ stdout ] Run -> semantic analysis
     --irgen     [ stdout ] Run -> IR generation
     --codegen   [ stdout ] Run -> code generation
     --emit      [ stdout ] Run -> code emission
 -S              [  file  ] Output asm to file (do not run assembler or linker)
 -c              [  file  ] Output object file (do not run linker)
EOF
  exit
}

cleanup() {
  trap - SIGINT SIGTERM ERR EXIT
  [[ -v preprocessed_file ]] && rm -f $preprocessed_file
  [[ -v assembly_file ]] && rm -f $assembly_file
}

msg() {
  echo >&2 -e "${1-}"
}

die() {
  local msg=$1
  local code=${2-1} # default exit status 1
  msg "$msg"
  exit "$code"
}

parse_params() {
  # compiler defaults to code emission, assembly and linking
  phase=7
  assy_link=2
  modes=0

  args=()

  while [[ $# -gt 0 ]]; do
    case "${1-}" in
    -h | --help) usage ;;
    -d | --debug) set -x ;;
    --lex)
      ((modes + 1))
      phase=1
      assy_link=0
      ;;
    --parse)
      ((modes + 1))
      phase=2
      assy_link=0
      ;;
    --validate)
      ((modes + 1))
      phase=3
      assy_link=0
      ;;
    --irgen)
      ((modes + 1))
      phase=4
      assy_link=0
      ;;
    --codegen)
      ((modes + 1))
      phase=5
      assy_link=0
      ;;
    --emit)
      ((modes + 1))
      phase=6
      assy_link=0
      ;;  
    -S)
      ((modes + 1))
      phase=7
      assy_link=0
      ;;
    -c)
      ((modes + 1))
      phase=7
      assy_link=1
      ;;
    -?*) die "ERROR: unknown option [$1]" ;;
    *) args+=($1) ;;
    esac
    shift
  done

  # check required params and arguments
  [[ ${#args[@]} -eq 0 ]] && die "ERROR: missing input C sourcefile path."
  [[ ${#args[@]} -ne 1 ]] && die "ERROR: provide a path to a single C sourcefile."
  [[ modes -gt 1 ]] && die "ERROR: flags [ --lex | --parse | --validate | --irgen | --codegen | --emit | -S | -c ] are mutually exclusive."

  return 0
}

# this compiler driver depends on gcc compiler
CC=gcc
command -v $CC >/dev/null 2>&1 || die "ERROR: a C compiler was not found on the system. Please install or add to PATH"

# subc compiler (.subc) should be installed alongside this script
SUBC="$script_dir/.subc"
[[ -f $SUBC ]] || die "ERROR: the subc compiler could not be found. Expected as ".subc" binary in same directory as this compiler driver"

parse_params "$@"

source_file="${args[0]}"
preprocessed_file="${source_file%.*}.i"
assembly_file="${source_file%.*}.s"

# check provided path to sourcefile appears valid
[[ "${source_file##*.}" != "c" ]] && die "ERROR: C sourcefile does not have a .c file extension."

# run C preprocessor (omit linemarkers)
$CC -E -P $source_file -o $preprocessed_file

# run sub-c compiler on preprocessed input
$SUBC $preprocessed_file $phase
#$CC -S -O -fno-asynchronous-unwind-tables -fcf-protection=none $preprocessed_file

if [[ $assy_link -eq 1 ]]; then
  # assemble only
  output_file="${source_file%.*}.o"
  $CC -c $assembly_file -o $output_file
elif [[ $assy_link -eq 2 ]]; then
  # assemble and link
  output_file="${source_file%.*}"
  $CC $assembly_file -o $output_file
fi
