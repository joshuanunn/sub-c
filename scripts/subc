#!/usr/bin/env bash

set -Eeuo pipefail

keep_asm=0
keep_obj=0
output_file="a.out"

preprocessed_files=()
assembly_files=()
object_files=()

trap cleanup SIGINT SIGTERM ERR EXIT

script_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd -P)

usage() {
  cat <<EOF
Usage: $(basename "${BASH_SOURCE[0]}") [-h] [-d] [-o] [--lex|--parse|--irgen|--codegen|--emit|-S|-c] sourcefile(s)
Sub-C compiler driver.
Available options:
 -h, --help      Print this help and exit
 -d, --debug     Print script debug info
 -o              Specify output filename for generated executable
     --lex       [ stdout ] Run -> lexer
     --parse     [ stdout ] Run -> parser
     --validate  [ stdout ] Run -> semantic analysis
     --irgen     [ stdout ] Run -> IR generation
     --codegen   [ stdout ] Run -> code generation
     --emit      [ stdout ] Run -> code emission
 -S              [  file  ] Output asm to file (do not run assembler or linker)
 -c              [  file  ] Output object file (do not run linker)
EOF
  exit
}

cleanup() {
  trap - SIGINT SIGTERM ERR EXIT

  for f in "${preprocessed_files[@]}"; do
    [[ -f $f ]] && rm -f "$f";
  done

  if [[ $keep_asm -eq 0 ]]; then
    for f in "${assembly_files[@]}"; do
      [[ -f $f ]] && rm -f "$f";
    done
  fi

  if [[ $keep_obj -eq 0 ]]; then
    for f in "${object_files[@]}"; do
      [[ -f $f ]] && rm -f "$f";
    done
  fi
}

msg() {
  echo >&2 -e "${1-}"
}

die() {
  local msg=$1
  local code=${2-1} # default exit status 1
  msg "$msg"
  exit "$code"
}

parse_params() {
  # compiler defaults to code emission, assembly and linking
  phase=7
  assy_link=2
  modes=0

  args=()

  while [[ $# -gt 0 ]]; do
    case "${1-}" in
    -h | --help) usage ;;
    -d | --debug) set -x ;;
    --lex)
      ((modes + 1))
      phase=1
      assy_link=0
      ;;
    --parse)
      ((modes + 1))
      phase=2
      assy_link=0
      ;;
    --validate)
      ((modes + 1))
      phase=3
      assy_link=0
      ;;
    --irgen)
      ((modes + 1))
      phase=4
      assy_link=0
      ;;
    --codegen)
      ((modes + 1))
      phase=5
      assy_link=0
      ;;
    --emit)
      ((modes + 1))
      phase=6
      assy_link=0
      ;;  
    -S)
      ((modes + 1))
      phase=7
      assy_link=0
      keep_asm=1
      ;;
    -c)
      ((modes + 1))
      phase=7
      assy_link=1
      keep_obj=1
      ;;
    -o)
      shift
      [[ $# -eq 0 ]] && die "ERROR: missing filename after -o"
      output_file="$1"
      ;;
    -?*) die "ERROR: unknown option [$1]" ;;
    *) args+=("$1") ;;
    esac
    shift
  done

  # check required params and arguments
  [[ ${#args[@]} -eq 0 ]] && die "ERROR: missing input C sourcefile path(s)."
  [[ modes -gt 1 ]] && die "ERROR: flags [ --lex | --parse | --validate | --irgen | --codegen | --emit | -S | -c ] are mutually exclusive."

  return 0
}

# this compiler driver depends on gcc compiler
CC=gcc
command -v $CC >/dev/null 2>&1 || die "ERROR: a C compiler was not found on the system. Please install or add to PATH"

# subc compiler (.subc) should be installed alongside this script
SUBC="$script_dir/.subc"
[[ -f $SUBC ]] || die "ERROR: the subc compiler could not be found. Expected as ".subc" binary in same directory as this compiler driver"

parse_params "$@"

for source_file in "${args[@]}"; do
  [[ "${source_file##*.}" != "c" ]] && die "ERROR: C sourcefile does not have a .c file extension."

  preprocessed_file="${source_file%.*}.i"
  assembly_file="${source_file%.*}.s"
  object_file="${source_file%.*}.o"

  preprocessed_files+=("$preprocessed_file")
  assembly_files+=("$assembly_file")
  object_files+=("$object_file")

  # run C preprocessor (omit linemarkers)
  $CC -E -P "$source_file" -o "$preprocessed_file"

  # run sub-c compiler on preprocessed input
  $SUBC "$preprocessed_file" $phase
  #$CC -S -O -fno-asynchronous-unwind-tables -fcf-protection=none $preprocessed_file

  # output object files if assembling
  if [[ $assy_link -ge 1 ]]; then
    $CC -c "$assembly_file" -o "$object_file"
  fi
done

# link all object files into one executable
if [[ $assy_link -eq 2 && ${#object_files[@]} -gt 0 ]]; then
  $CC "${object_files[@]}" -o "$output_file"
fi
