#!/usr/bin/env bash

set -Eeuo pipefail

keep_asm=0
keep_obj=0
output_file="a.out"

preprocessed_files=()
assembly_files=()
object_files=()

trap cleanup SIGINT SIGTERM ERR EXIT

script_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd -P)

usage() {
  cat <<EOF
Usage: $(basename "${BASH_SOURCE[0]}") [options] sourcefile(s)
Sub-C compiler driver.

Stages [mutually exclusive]:
     --lex                Stop after lexing; write to stdout
     --parse              Stop after parsing; write to stdout
     --validate           Stop after semantic analysis; write to stdout
     --irgen              Stop after IR generation; write to stdout
     --codegen            Stop after code generation; write to stdout
     --emit               Emit assembly to stdout

Optimisations [stackable]:
 -O, --opt-all            Enable all
     --opt-folding        Enable constant folding
     --opt-propagation    Enable copy propagation
     --opt-unreachable    Enable unreachable code elimination
     --opt-deadstores     Enable dead store elimination

Output:
 -S                       Emit assembly only (no assembler, no linker)
 -c                       Emit object file (no linker)
 -o <file>                Emit executable binary to <file> (default: a.out)

Help:
 -h, --help               Print this help and exit
 -d, --debug              Print script debug info
EOF
  exit
}

cleanup() {
  trap - SIGINT SIGTERM ERR EXIT

  for f in "${preprocessed_files[@]}"; do
    [[ -f $f ]] && rm -f "$f";
  done

  if [[ $keep_asm -eq 0 ]]; then
    for f in "${assembly_files[@]}"; do
      [[ -f $f ]] && rm -f "$f";
    done
  fi

  if [[ $keep_obj -eq 0 ]]; then
    for f in "${object_files[@]}"; do
      [[ -f $f ]] && rm -f "$f";
    done
  fi
}

msg() {
  echo >&2 -e "${1-}"
}

die() {
  local msg=$1
  local code=${2-1} # default exit status 1
  msg "$msg"
  exit "$code"
}

parse_params() {
  # compiler defaults to code emission, assembly and linking
  phase=7
  assy_link=2
  modes=0

  # optimisation bitmask defaults
  OPT_NONE=0
  OPT_FOLDING=1
  OPT_PROPAGATION=2
  OPT_UNREACHABLE=4
  OPT_DEADSTORES=8
  OPT_ALL=$((OPT_FOLDING | OPT_PROPAGATION | OPT_UNREACHABLE | OPT_DEADSTORES))
  opt_flags=$OPT_NONE

  args=()

  while [[ $# -gt 0 ]]; do
    case "${1-}" in
    -h | --help) usage ;;
    -d | --debug) set -x ;;

    # Compilation stages [mutually exclusive]
    --lex)       ((modes+=1)); phase=1; assy_link=0 ;;
    --parse)     ((modes+=1)); phase=2; assy_link=0 ;;
    --validate)  ((modes+=1)); phase=3; assy_link=0 ;;
    --irgen)     ((modes+=1)); phase=4; assy_link=0 ;;
    --codegen)   ((modes+=1)); phase=5; assy_link=0 ;;
    --emit)      ((modes+=1)); phase=6; assy_link=0 ;;

    # Optimisations [stackable]
    -O | --opt-all)     opt_flags=$OPT_ALL ;;
    --opt-folding)      ((opt_flags |= OPT_FOLDING)) ;;
    --opt-propagation)  ((opt_flags |= OPT_PROPAGATION)) ;;
    --opt-unreachable)  ((opt_flags |= OPT_UNREACHABLE)) ;;
    --opt-deadstores)   ((opt_flags |= OPT_DEADSTORES)) ;;

    # Output modes
    -S) ((modes+=1)); phase=7; assy_link=0; keep_asm=1 ;;
    -c) ((modes+=1)); phase=7; assy_link=1; keep_obj=1 ;;
    -o)
      shift
      [[ $# -eq 0 ]] && die "ERROR: missing filename after -o"
      output_file="$1"
      ;;
    -?*) die "ERROR: unknown option [$1]" ;;
    *) args+=("$1") ;;
    esac
    shift
  done

  # check required params and arguments
  [[ ${#args[@]} -eq 0 ]] && die "ERROR: missing input C sourcefile path(s)."
  [[ modes -gt 1 ]] && die "ERROR: flags [ --lex | --parse | --validate | --irgen | --codegen | --emit | -S | -c ] are mutually exclusive."

  return 0
}

# this compiler driver depends on gcc compiler
CC=gcc
command -v $CC >/dev/null 2>&1 || die "ERROR: a C compiler was not found on the system. Please install or add to PATH"

# subc compiler (.subc) should be installed alongside this script
SUBC="$script_dir/.subc"
[[ -f $SUBC ]] || die "ERROR: the subc compiler could not be found. Expected as ".subc" binary in same directory as this compiler driver"

parse_params "$@"

for source_file in "${args[@]}"; do
  [[ "${source_file##*.}" != "c" ]] && die "ERROR: C sourcefile does not have a .c file extension."

  preprocessed_file="${source_file%.*}.i"
  assembly_file="${source_file%.*}.s"
  object_file="${source_file%.*}.o"

  preprocessed_files+=("$preprocessed_file")
  assembly_files+=("$assembly_file")
  object_files+=("$object_file")

  # run C preprocessor (omit linemarkers)
  $CC -E -P "$source_file" -o "$preprocessed_file"

  # run sub-c compiler on preprocessed input
  $SUBC "$preprocessed_file" $phase $opt_flags
  #$CC -S -O -fno-asynchronous-unwind-tables -fcf-protection=none $preprocessed_file

  # output object files if assembling
  if [[ $assy_link -ge 1 ]]; then
    $CC -c "$assembly_file" -o "$object_file"
  fi
done

# link all object files into one executable
if [[ $assy_link -eq 2 && ${#object_files[@]} -gt 0 ]]; then
  $CC "${object_files[@]}" -o "$output_file"
fi
